{"version":3,"sources":["../../../whammy.js"],"names":["window","Whammy","toWebM","frames","outputAsArray","frameNumber","info","num","checkFrames","width","height","duration","i","length","EBML","id","data","slice","call","Uint8Array","Float64Array","buffer","map","e","String","fromCharCode","reverse","join","segment","cues","clusterTimecode","cuePoint","Math","round","size","push","clusterFrames","clusterDuration","clusterCounter","cluster","concat","webp","block","makeSimpleBlock","discardable","frame","invisible","keyframe","lacing","trackNum","timecode","position","generateEBML","byteLength","numToBuffer","parts","numToFixedBuffer","strToBuffer","str","arr","charCodeAt","bitsToBuffer","bits","Array","parseInt","substr","json","ebml","toString","len","zeroes","ceil","log","size_str","padded","toFlatArray","outBuffer","Blob","type","flags","out","parseWebP","riff","VP8","tmp","RIFF","WEBP","frame_start","indexOf","c","parseRIFF","string","offset","chunks","split","unpadded","WhammyVideo","speed","quality","prototype","add","canvas","toDataURL","getContext","getImageData","test","image","encodeFrames","callback","ImageData","tmpCanvas","document","createElement","tmpContext","encodeFrame","index","console","putImageData","setTimeout","bind","compile","webm","atob","Video","fromImageArray","images","fps"],"mappings":"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","file":"whammy.77c87d28.js","sourceRoot":"../src","sourcesContent":["/*\n\tvar vid = new Whammy.Video();\n\tvid.add(canvas or data url)\n\tvid.compile()\n*/\n\nwindow.Whammy = (function () {\n  // in this case, frames has a very specific meaning, which will be\n  // detailed once i finish writing the code\n\n  function toWebM(frames, outputAsArray) {\n    const info = checkFrames(frames);\n\n    // max duration by cluster in milliseconds\n    const CLUSTER_MAX_DURATION = 30000;\n\n    const EBML = [\n      {\n        id: 0x1a45dfa3, // EBML\n        data: [\n          {\n            data: 1,\n            id: 0x4286, // EBMLVersion\n          },\n          {\n            data: 1,\n            id: 0x42f7, // EBMLReadVersion\n          },\n          {\n            data: 4,\n            id: 0x42f2, // EBMLMaxIDLength\n          },\n          {\n            data: 8,\n            id: 0x42f3, // EBMLMaxSizeLength\n          },\n          {\n            data: 'webm',\n            id: 0x4282, // DocType\n          },\n          {\n            data: 2,\n            id: 0x4287, // DocTypeVersion\n          },\n          {\n            data: 2,\n            id: 0x4285, // DocTypeReadVersion\n          },\n        ],\n      },\n      {\n        id: 0x18538067, // Segment\n        data: [\n          {\n            id: 0x1549a966, // Info\n            data: [\n              {\n                data: 1e6, // do things in millisecs (num of nanosecs for duration scale)\n                id: 0x2ad7b1, // TimecodeScale\n              },\n              {\n                data: 'whammy',\n                id: 0x4d80, // MuxingApp\n              },\n              {\n                data: 'whammy',\n                id: 0x5741, // WritingApp\n              },\n              {\n                data: doubleToString(info.duration),\n                id: 0x4489, // Duration\n              },\n            ],\n          },\n          {\n            id: 0x1654ae6b, // Tracks\n            data: [\n              {\n                id: 0xae, // TrackEntry\n                data: [\n                  {\n                    data: 1,\n                    id: 0xd7, // TrackNumber\n                  },\n                  {\n                    data: 1,\n                    id: 0x73c5, // TrackUID\n                  },\n                  {\n                    data: 0,\n                    id: 0x9c, // FlagLacing\n                  },\n                  {\n                    data: 'und',\n                    id: 0x22b59c, // Language\n                  },\n                  {\n                    data: 'V_VP8',\n                    id: 0x86, // CodecID\n                  },\n                  {\n                    data: 'VP8',\n                    id: 0x258688, // CodecName\n                  },\n                  {\n                    data: 1,\n                    id: 0x83, // TrackType\n                  },\n                  {\n                    id: 0xe0, // Video\n                    data: [\n                      {\n                        data: info.width,\n                        id: 0xb0, // PixelWidth\n                      },\n                      {\n                        data: info.height,\n                        id: 0xba, // PixelHeight\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            id: 0x1c53bb6b, // Cues\n            data: [\n              // cue insertion point\n            ],\n          },\n\n          // cluster insertion point\n        ],\n      },\n    ];\n\n    const segment = EBML[1];\n    const cues = segment.data[2];\n\n    // Generate clusters (max duration)\n    let frameNumber = 0;\n    let clusterTimecode = 0;\n    while (frameNumber < frames.length) {\n      const cuePoint = {\n        id: 0xbb, // CuePoint\n        data: [\n          {\n            data: Math.round(clusterTimecode),\n            id: 0xb3, // CueTime\n          },\n          {\n            id: 0xb7, // CueTrackPositions\n            data: [\n              {\n                data: 1,\n                id: 0xf7, // CueTrack\n              },\n              {\n                data: 0, // to be filled in when we know it\n                size: 8,\n                id: 0xf1, // CueClusterPosition\n              },\n            ],\n          },\n        ],\n      };\n\n      cues.data.push(cuePoint);\n\n      const clusterFrames = [];\n      let clusterDuration = 0;\n      do {\n        clusterFrames.push(frames[frameNumber]);\n        clusterDuration += frames[frameNumber].duration;\n        frameNumber++;\n      } while (\n        frameNumber < frames.length &&\n        clusterDuration < CLUSTER_MAX_DURATION\n      );\n\n      var clusterCounter = 0;\n      const cluster = {\n        id: 0x1f43b675, // Cluster\n        data: [\n          {\n            data: Math.round(clusterTimecode),\n            id: 0xe7, // Timecode\n          },\n        ].concat(\n          clusterFrames.map(function (webp) {\n            const block = makeSimpleBlock({\n              discardable: 0,\n              frame: webp.data.slice(4),\n              invisible: 0,\n              keyframe: 1,\n              lacing: 0,\n              trackNum: 1,\n              timecode: Math.round(clusterCounter),\n            });\n            clusterCounter += webp.duration;\n            return {\n              data: block,\n              id: 0xa3,\n            };\n          }),\n        ),\n      };\n\n      // Add cluster to segment\n      segment.data.push(cluster);\n      clusterTimecode += clusterDuration;\n    }\n\n    // First pass to compute cluster positions\n    let position = 0;\n    for (let i = 0; i < segment.data.length; i++) {\n      if (i >= 3) {\n        cues.data[i - 3].data[1].data[1].data = position;\n      }\n      const data = generateEBML([segment.data[i]], outputAsArray);\n      position += data.size || data.byteLength || data.length;\n      if (i != 2) {\n        // not cues\n        // Save results to avoid having to encode everything twice\n        segment.data[i] = data;\n      }\n    }\n\n    return generateEBML(EBML, outputAsArray);\n  }\n\n  // sums the lengths of all the frames and gets the duration, woo\n\n  function checkFrames(frames) {\n    const { width } = frames[0];\n    const { height } = frames[0];\n    let { duration } = frames[0];\n    for (let i = 1; i < frames.length; i++) {\n      if (frames[i].width != width)\n        throw `Frame ${i + 1} has a different width`;\n      if (frames[i].height != height)\n        throw `Frame ${i + 1} has a different height`;\n      if (frames[i].duration < 0 || frames[i].duration > 0x7fff)\n        throw `Frame ${\n          i + 1\n        } has a weird duration (must be between 0 and 32767)`;\n      duration += frames[i].duration;\n    }\n    return {\n      duration,\n      width,\n      height,\n    };\n  }\n\n  function numToBuffer(num) {\n    const parts = [];\n    while (num > 0) {\n      parts.push(num & 0xff);\n      num >>= 8;\n    }\n    return new Uint8Array(parts.reverse());\n  }\n\n  function numToFixedBuffer(num, size) {\n    const parts = new Uint8Array(size);\n    for (let i = size - 1; i >= 0; i--) {\n      parts[i] = num & 0xff;\n      num >>= 8;\n    }\n    return parts;\n  }\n\n  function strToBuffer(str) {\n    // return new Blob([str]);\n\n    const arr = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; i++) {\n      arr[i] = str.charCodeAt(i);\n    }\n    return arr;\n    // this is slower\n    // return new Uint8Array(str.split('').map(function(e){\n    // \treturn e.charCodeAt(0)\n    // }))\n  }\n\n  // sorry this is ugly, and sort of hard to understand exactly why this was done\n  // at all really, but the reason is that there's some code below that i dont really\n  // feel like understanding, and this is easier than using my brain.\n\n  function bitsToBuffer(bits) {\n    const data = [];\n    const pad =\n      bits.length % 8 ? new Array(1 + 8 - (bits.length % 8)).join('0') : '';\n    bits = pad + bits;\n    for (let i = 0; i < bits.length; i += 8) {\n      data.push(parseInt(bits.substr(i, 8), 2));\n    }\n    return new Uint8Array(data);\n  }\n\n  function generateEBML(json, outputAsArray) {\n    const ebml = [];\n    for (let i = 0; i < json.length; i++) {\n      if (!('id' in json[i])) {\n        // already encoded blob or byteArray\n        ebml.push(json[i]);\n        continue;\n      }\n\n      let { data } = json[i];\n      if (typeof data === 'object') data = generateEBML(data, outputAsArray);\n      if (typeof data === 'number')\n        data =\n          'size' in json[i]\n            ? numToFixedBuffer(data, json[i].size)\n            : bitsToBuffer(data.toString(2));\n      if (typeof data === 'string') data = strToBuffer(data);\n\n      if (data.length) {\n        var z = z;\n      }\n\n      const len = data.size || data.byteLength || data.length;\n      const zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\n      const size_str = len.toString(2);\n      const padded =\n        new Array(zeroes * 7 + 7 + 1 - size_str.length).join('0') + size_str;\n      const size = `${new Array(zeroes).join('0')}1${padded}`;\n\n      // i actually dont quite understand what went on up there, so I'm not really\n      // going to fix this, i'm probably just going to write some hacky thing which\n      // converts that string into a buffer-esque thing\n\n      ebml.push(numToBuffer(json[i].id));\n      ebml.push(bitsToBuffer(size));\n      ebml.push(data);\n    }\n\n    // output as blob or byteArray\n    if (outputAsArray) {\n      // convert ebml to an array\n      const buffer = toFlatArray(ebml);\n      return new Uint8Array(buffer);\n    }\n    return new Blob(ebml, { type: 'video/webm' });\n  }\n\n  function toFlatArray(arr, outBuffer) {\n    if (outBuffer == null) {\n      outBuffer = [];\n    }\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof arr[i] === 'object') {\n        // an array\n        toFlatArray(arr[i], outBuffer);\n      } else {\n        // a simple element\n        outBuffer.push(arr[i]);\n      }\n    }\n    return outBuffer;\n  }\n\n  // OKAY, so the following two functions are the string-based old stuff, the reason they're\n  // still sort of in here, is that they're actually faster than the new blob stuff because\n  // getAsFile isn't widely implemented, or at least, it doesn't work in chrome, which is the\n  // only browser which supports get as webp\n\n  // Converting between a string of 0010101001's and binary back and forth is probably inefficient\n  // TODO: get rid of this function\n  function toBinStr_old(bits) {\n    let data = '';\n    const pad =\n      bits.length % 8 ? new Array(1 + 8 - (bits.length % 8)).join('0') : '';\n    bits = pad + bits;\n    for (let i = 0; i < bits.length; i += 8) {\n      data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\n    }\n    return data;\n  }\n\n  function generateEBML_old(json) {\n    let ebml = '';\n    for (let i = 0; i < json.length; i++) {\n      let { data } = json[i];\n      if (typeof data === 'object') data = generateEBML_old(data);\n      if (typeof data === 'number') data = toBinStr_old(data.toString(2));\n\n      const len = data.length;\n      const zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\n      const size_str = len.toString(2);\n      const padded =\n        new Array(zeroes * 7 + 7 + 1 - size_str.length).join('0') + size_str;\n      const size = `${new Array(zeroes).join('0')}1${padded}`;\n\n      ebml += toBinStr_old(json[i].id.toString(2)) + toBinStr_old(size) + data;\n    }\n    return ebml;\n  }\n\n  // woot, a function that's actually written for this project!\n  // this parses some json markup and makes it into that binary magic\n  // which can then get shoved into the matroska comtainer (peaceably)\n\n  function makeSimpleBlock(data) {\n    let flags = 0;\n    if (data.keyframe) flags |= 128;\n    if (data.invisible) flags |= 8;\n    if (data.lacing) flags |= data.lacing << 1;\n    if (data.discardable) flags |= 1;\n    if (data.trackNum > 127) {\n      throw 'TrackNumber > 127 not supported';\n    }\n    const out =\n      [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags]\n        .map(function (e) {\n          return String.fromCharCode(e);\n        })\n        .join('') + data.frame;\n\n    return out;\n  }\n\n  // here's something else taken verbatim from weppy, awesome rite?\n\n  function parseWebP(riff) {\n    const VP8 = riff.RIFF[0].WEBP[0];\n\n    const frame_start = VP8.indexOf('\\x9d\\x01\\x2a'); // A VP8 keyframe starts with the 0x9d012a header\n    for (var i = 0, c = []; i < 4; i++)\n      c[i] = VP8.charCodeAt(frame_start + 3 + i);\n\n    let width;\n    let horizontal_scale;\n    let height;\n    let vertical_scale;\n    let tmp;\n\n    // the code below is literally copied verbatim from the bitstream spec\n    tmp = (c[1] << 8) | c[0];\n    width = tmp & 0x3fff;\n    horizontal_scale = tmp >> 14;\n    tmp = (c[3] << 8) | c[2];\n    height = tmp & 0x3fff;\n    vertical_scale = tmp >> 14;\n    return {\n      width,\n      height,\n      data: VP8,\n      riff,\n    };\n  }\n\n  // i think i'm going off on a riff by pretending this is some known\n  // idiom which i'm making a casual and brilliant pun about, but since\n  // i can't find anything on google which conforms to this idiomatic\n  // usage, I'm assuming this is just a consequence of some psychotic\n  // break which makes me make up puns. well, enough riff-raff (aha a\n  // rescue of sorts), this function was ripped wholesale from weppy\n\n  function parseRIFF(string) {\n    let offset = 0;\n    const chunks = {};\n\n    while (offset < string.length) {\n      const id = string.substr(offset, 4);\n      chunks[id] = chunks[id] || [];\n      if (id == 'RIFF' || id == 'LIST') {\n        const len = parseInt(\n          string\n            .substr(offset + 4, 4)\n            .split('')\n            .map(function (i) {\n              const unpadded = i.charCodeAt(0).toString(2);\n              return new Array(8 - unpadded.length + 1).join('0') + unpadded;\n            })\n            .join(''),\n          2,\n        );\n        const data = string.substr(offset + 4 + 4, len);\n        offset += 4 + 4 + len;\n        chunks[id].push(parseRIFF(data));\n      } else if (id == 'WEBP') {\n        // Use (offset + 8) to skip past \"VP8 \"/\"VP8L\"/\"VP8X\" field after \"WEBP\"\n        chunks[id].push(string.substr(offset + 8));\n        offset = string.length;\n      } else {\n        // Unknown chunk type; push entire payload\n        chunks[id].push(string.substr(offset + 4));\n        offset = string.length;\n      }\n    }\n    return chunks;\n  }\n\n  // here's a little utility function that acts as a utility for other functions\n  // basically, the only purpose is for encoding \"Duration\", which is encoded as\n  // a double (considerably more difficult to encode than an integer)\n  function doubleToString(num) {\n    return [].slice\n      .call(\n        new Uint8Array(\n          new Float64Array([num]).buffer, // create a float64 array\n        ), // extract the array buffer\n        0,\n      ) // convert the Uint8Array into a regular array\n      .map(function (e) {\n        // since it's a regular array, we can now use map\n        return String.fromCharCode(e); // encode all the bytes individually\n      })\n      .reverse() // correct the byte endianness (assume it's little endian for now)\n      .join(''); // join the bytes in holy matrimony as a string\n  }\n\n  function WhammyVideo(speed, quality) {\n    // a more abstract-ish API\n    this.frames = [];\n    this.duration = 1000 / speed;\n    this.quality = quality || 0.8;\n  }\n\n  WhammyVideo.prototype.add = function (frame, duration) {\n    if (typeof duration !== 'undefined' && this.duration)\n      throw \"you can't pass a duration if the fps is set\";\n    if (typeof duration === 'undefined' && !this.duration)\n      throw \"if you don't have the fps set, you need to have durations here.\";\n    if (frame.canvas) {\n      // CanvasRenderingContext2D\n      frame = frame.canvas;\n    }\n    if (frame.toDataURL) {\n      // frame = frame.toDataURL('image/webp', this.quality);\n      // quickly store image data so we don't block cpu. encode in compile method.\n      frame = frame\n        .getContext('2d')\n        .getImageData(0, 0, frame.width, frame.height);\n    } else if (typeof frame !== 'string') {\n      throw 'frame must be a a HTMLCanvasElement, a CanvasRenderingContext2D or a DataURI formatted string';\n    }\n    if (\n      typeof frame === 'string' &&\n      !/^data:image\\/webp;base64,/gi.test(frame)\n    ) {\n      throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';\n    }\n    this.frames.push({\n      image: frame,\n      duration: duration || this.duration,\n    });\n  };\n\n  // deferred webp encoding. Draws image data to canvas, then encodes as dataUrl\n  WhammyVideo.prototype.encodeFrames = function (callback) {\n    if (this.frames[0].image instanceof ImageData) {\n      const { frames } = this;\n      const tmpCanvas = document.createElement('canvas');\n      const tmpContext = tmpCanvas.getContext('2d');\n      tmpCanvas.width = this.frames[0].image.width;\n      tmpCanvas.height = this.frames[0].image.height;\n\n      var encodeFrame = function (index) {\n        console.log('encodeFrame', index);\n        const frame = frames[index];\n        tmpContext.putImageData(frame.image, 0, 0);\n        frame.image = tmpCanvas.toDataURL('image/webp', this.quality);\n        if (index < frames.length - 1) {\n          setTimeout(function () {\n            encodeFrame(index + 1);\n          }, 1);\n        } else {\n          callback();\n        }\n      }.bind(this);\n\n      encodeFrame(0);\n    } else {\n      callback();\n    }\n  };\n\n  WhammyVideo.prototype.compile = function (outputAsArray, callback) {\n    this.encodeFrames(\n      function () {\n        const webm = new toWebM(\n          this.frames.map(function (frame) {\n            const webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\n            webp.duration = frame.duration;\n            return webp;\n          }),\n          outputAsArray,\n        );\n        callback(webm);\n      }.bind(this),\n    );\n  };\n\n  return {\n    Video: WhammyVideo,\n    fromImageArray(images, fps, outputAsArray) {\n      return toWebM(\n        images.map(function (image) {\n          const webp = parseWebP(parseRIFF(atob(image.slice(23))));\n          webp.duration = 1000 / fps;\n          return webp;\n        }),\n        outputAsArray,\n      );\n    },\n    toWebM,\n    // expose methods of madness\n  };\n})();\n"]}